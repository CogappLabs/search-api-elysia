---
title: Adding a Search Engine
description: How to add a new search engine backend (e.g. Typesense).
---

import { Steps, FileTree } from "@astrojs/starlight/components";

The API uses an engine abstraction that makes it straightforward to add new search backends. Four engines are currently implemented: Elasticsearch, OpenSearch, Meilisearch, and Typesense.

## Architecture

Elasticsearch and OpenSearch share a base class (`ElasticCompatEngine`) since they use an identical query DSL. Subclasses only differ in client construction and response unwrapping. Meilisearch and Typesense implement `SearchEngine` directly because their API models are fundamentally different.

<FileTree>

- src/engines/
  - **engine.ts** SearchEngine interface
  - elastic-compat.ts shared base class
  - elasticsearch.ts
  - opensearch.ts
  - meilisearch.ts
  - typesense.ts
  - **index.ts** engine factory map

</FileTree>

## Adding a new engine

<Steps>

1. **Implement the `SearchEngine` interface**

   Create a new file in `src/engines/` (e.g. `typesense.ts`). Your class must implement all five methods from `src/engines/engine.ts`:

   ```typescript
   import type {
     FacetSearchOptions,
     FacetValue,
     SearchOptions,
     SearchResult,
   } from "../types.ts";

   export interface SearchEngine {
     search(query: string, options: SearchOptions): Promise<SearchResult>;
     getDocument(id: string): Promise<Record<string, unknown> | null>;
     searchFacetValues(
       field: string,
       query: string,
       options?: FacetSearchOptions,
     ): Promise<FacetValue[]>;
     getMapping(): Promise<Record<string, unknown>>;
     rawQuery(body: Record<string, unknown>): Promise<Record<string, unknown>>;
   }
   ```

   #### Method details

   | Method | Purpose |
   | --- | --- |
   | `search` | Full-text search with pagination, facets, filters, boosts, highlights, histograms, and geo grid. Return a `SearchResult`. |
   | `getDocument` | Fetch a single document by ID. Return `null` if not found. |
   | `searchFacetValues` | Search within a facet field's values by name. Used for autocomplete-style facet filtering. |
   | `getMapping` | Return the index schema/mapping. Structure depends on the engine. |
   | `rawQuery` | Pass a raw query body to the engine. The body shape is engine-specific. |

   Your constructor receives the full `IndexConfig` and should extract what it needs (host, auth, index name).

   :::tip
   If your engine uses the Elasticsearch query DSL (like OpenSearch does), consider extending `ElasticCompatEngine` instead — see `src/engines/elasticsearch.ts` and `src/engines/opensearch.ts` for examples of thin subclasses.
   :::

   For engines with a completely different API model, implement `SearchEngine` directly — see `src/engines/meilisearch.ts`.

2. **Register the engine**

   Add your engine to the factory map in `src/engines/index.ts`:

   ```typescript
   import { TypesenseEngine } from "./typesense.ts";

   const engineFactories: Record<string, (config: IndexConfig) => SearchEngine> = {
     elasticsearch: (config) => new ElasticsearchEngine(config),
     opensearch: (config) => new OpenSearchEngine(config),
     meilisearch: (config) => new MeilisearchEngine(config),
     typesense: (config) => new TypesenseEngine(config),
   };
   ```

3. **Update the config schema**

   Add the new engine name as a valid literal in `src/config.ts`:

   ```typescript
   const IndexConfigSchema = t.Object({
     engine: t.Union([
       t.Literal("elasticsearch"),
       t.Literal("opensearch"),
       t.Literal("meilisearch"),
       t.Literal("typesense"),
     ]),
     // ...
   });
   ```

   Also update `schemas/config.schema.json` to include the new engine in the `enum`:

   ```json
   "engine": {
     "type": "string",
     "enum": ["elasticsearch", "opensearch", "meilisearch", "typesense"]
   }
   ```

</Steps>

## Notes

:::note
- The `SearchEngine` interface is engine-agnostic. All engine-specific logic stays inside the engine class.
- Auth fields on `IndexConfig` (`apiKey`, `username`, `password`) are shared. If your engine needs different auth, you can use these same fields or extend `IndexConfig` with engine-specific options.
- The `fields` config, alias maps, boosts, and searchable fields are all resolved at the route layer before reaching the engine. Your engine receives pre-translated field names via `SearchOptions`.
- The `rawQuery` endpoint passes the body directly — document the expected format for your engine.
- Features your engine doesn't support (e.g. histograms, geoGrid, suggest) should return graceful defaults (empty arrays/objects, `undefined`).
:::
